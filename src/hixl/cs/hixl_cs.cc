/**
 * Copyright (c) 2026 Huawei Technologies Co., Ltd.
 * This program is free software, you can redistribute it and/or modify it under the terms and conditions of
 * CANN Open Software License Agreement Version 2.0 (the "License").
 * Please refer to the License for details. You may not use this file except in compliance with the License.
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
 * See LICENSE in the root of the software repository for the full text of the License.
 */

#include "common/hixl_cs.h"
#include "hixl/hixl_types.h"
#include "common/hixl_log.h"
#include "common/ctrl_msg.h"
#include "common/hixl_checker.h"
#include "common/scope_guard.h"
#include "hixl_cs_server.h"
#include "hixl_cs_client.h"

HixlStatus HixlCSServerCreate(const HixlServerDesc *server_desc,
                              const HixlServerConfig *config, HixlServerHandle *server_handle) {
  HIXL_CHECK_NOTNULL(server_handle);
  HIXL_CHECK_NOTNULL(server_desc);
  auto server = new (std::nothrow) hixl::HixlCSServer(server_desc->server_ip, server_desc->server_port);
  HIXL_CHECK_NOTNULL(server);
  HIXL_DISMISSABLE_GUARD(rollback, ([server]() { delete server; }));
  HIXL_CHK_STATUS_RET(server->Initialize(server_desc->endpoint_list, server_desc->endpoint_list_num, config),
                      "Failed to init hixl cs server, ip:%s, port:%u",
                      server_desc->server_ip, server_desc->server_port);
  HIXL_DISMISS_GUARD(rollback);
  *server_handle = server;
  HIXL_EVENT("[HixlCSServer] create server success, server_handle:%p", *server_handle);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSServerDestroy(HixlServerHandle server_handle) {
  auto server = static_cast<hixl::HixlCSServer *>(server_handle);
  HIXL_CHECK_NOTNULL(server, ", please use handle generated by HixlCSServerCreate");
  HIXL_MAKE_GUARD(release, ([server]() { delete server; }));
  HIXL_CHK_STATUS_RET(server->Finalize(), "Failed to finalize hixl cs server, server_handle:%p", server_handle);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSServerRegMem(HixlServerHandle server_handle, const char *mem_tag, const HcommMem *mem,
                              MemHandle *mem_handle) {
  auto server = static_cast<hixl::HixlCSServer *>(server_handle);
  HIXL_CHECK_NOTNULL(server, ", please use handle generated by HixlCSServerCreate");
  HIXL_CHECK_NOTNULL(mem);
  HIXL_CHK_STATUS_RET(server->RegisterMem(mem_tag, mem, mem_handle), "Failed to register server mem");
  return HIXL_SUCCESS;
}

HixlStatus HixlCSServerUnregMem(HixlServerHandle server_handle, MemHandle mem_handle) {
  auto server = static_cast<hixl::HixlCSServer *>(server_handle);
  HIXL_CHECK_NOTNULL(server, ", please use handle generated by HixlCSServerCreate");
  HIXL_CHECK_NOTNULL(mem_handle);
  HIXL_CHK_STATUS_RET(server->DeregisterMem(mem_handle), "Failed to deregister server mem, mem_handle:%p", mem_handle);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSServerListen(HixlServerHandle server_handle, uint32_t backlog) {
  auto server = static_cast<hixl::HixlCSServer *>(server_handle);
  HIXL_CHECK_NOTNULL(server, ", please use handle generated by HixlCSServerCreate");
  HIXL_CHK_STATUS_RET(server->Listen(backlog), "Failed to start server listen, backlog:%u", backlog);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientCreate(const HixlClientDesc *client_desc, const HixlClientConfig *config,
                              HixlClientHandle *client_handle) {
  HIXL_CHECK_NOTNULL(client_handle);
  auto *client = new (std::nothrow) hixl::HixlCSClient();
  HIXL_CHECK_NOTNULL(client);
  HIXL_DISMISSABLE_GUARD(rollback, ([client]() { delete client; }));
  const auto ret = client->Create(client_desc->server_ip, client_desc->server_port, client_desc->src_endpoint,
                                  client_desc->dst_endpoint, config);
  HIXL_CHK_STATUS_RET(ret,
                      "Failed to create hixl cs client, "
                      "server_ip:%s, server_port:%u",
                      client_desc->server_ip, client_desc->server_port);
  *client_handle = static_cast<HixlClientHandle>(client);
  HIXL_DISMISS_GUARD(rollback);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientRegMem(HixlClientHandle client_handle, const char *mem_tag, const HcommMem *mem,
                              MemHandle *mem_handle) {
  HIXL_CHECK_NOTNULL(client_handle);
  HIXL_CHECK_NOTNULL(mem);
  HIXL_CHECK_NOTNULL(mem_handle);
  auto client = static_cast<hixl::HixlCSClient *>(client_handle);
  const auto ret = client->RegMem(mem_tag, mem, mem_handle);
  HIXL_CHK_STATUS_RET(ret, "HixlCSClientRegMem failed, client_handle is %p, mem_tag: %s, mem_adrr: %p, mem_size: %lu.",
                      client_handle, (mem_tag != nullptr ? mem_tag : "(null)"), mem->addr, mem->size);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientUnregMem(HixlClientHandle client_handle, MemHandle mem_handle) {
  HIXL_CHECK_NOTNULL(client_handle);
  HIXL_CHECK_NOTNULL(mem_handle);
  auto client = static_cast<hixl::HixlCSClient *>(client_handle);
  const auto ret = client->UnRegMem(mem_handle);
  HIXL_CHK_STATUS_RET(ret, "HixlCSClientUnregMem failed, client_handle is %p.", client_handle);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientBatchPutAsync(HixlClientHandle client_handle, uint32_t list_num,
                                     const HixlOneSideOpDesc *desc_list, CompleteHandle *complete_handle) {
  HIXL_CHECK_NOTNULL(client_handle);
  if (list_num > 0) {
    HIXL_CHECK_NOTNULL(desc_list);
  } else {
    HIXL_LOGE(HIXL_PARAM_INVALID,
              "[HixlCSClientBatchPutAsync] The value of list_num is invalid. client_handle is %p, list_num: %u",
              client_handle, list_num);
    return HIXL_PARAM_INVALID;
  }
  HIXL_CHECK_NOTNULL(complete_handle);
  auto client = static_cast<hixl::HixlCSClient *>(client_handle);
  std::vector<void *> remote_bufs(list_num);
  std::vector<const void *> local_bufs(list_num);
  std::vector<uint64_t> lens(list_num);
  for (uint32_t i = 0; i < list_num; ++i) {
    remote_bufs[i] = desc_list[i].remote_buf;
    local_bufs[i] = desc_list[i].local_buf;
    lens[i] = desc_list[i].len;
  }
  hixl::CommunicateMem com_mem{};
  com_mem.list_num = list_num;
  com_mem.dst_buf_list = remote_bufs.data();  // Put 操作：dst 是 remote
  com_mem.src_buf_list = local_bufs.data();   // Put 操作：src 是 local
  com_mem.len_list = lens.data();
  void *raw_handle = nullptr;
  const auto ret = client->BatchTransfer(false, com_mem, &raw_handle);
  if (raw_handle != nullptr) {
    *complete_handle = raw_handle;
    HIXL_LOGI("HixlCSClientBatchPutAsync complete_handle create, complete_handle is %p.", complete_handle);
  }
  HIXL_CHK_STATUS_RET(ret, "HixlCSClientBatchPutAsync failed, client_handle is %p, list_num:%u", client_handle,
                      list_num);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientBatchGetAsync(HixlClientHandle client_handle, uint32_t list_num,
                                     const HixlOneSideOpDesc *desc_list, CompleteHandle *complete_handle) {
  HIXL_CHECK_NOTNULL(client_handle);
  if (list_num > 0) {
    HIXL_CHECK_NOTNULL(desc_list);
  } else {
    HIXL_LOGE(HIXL_PARAM_INVALID,
              "[HixlCSClientBatchGetAsync] The value of list_num is invalid. client_handle is %p, list_num: %u",
              client_handle, list_num);
    return HIXL_PARAM_INVALID;
  }
  HIXL_CHECK_NOTNULL(complete_handle);
  auto client = static_cast<hixl::HixlCSClient *>(client_handle);
  std::vector<void *> local_bufs(list_num);
  std::vector<const void *> remote_bufs(list_num);  // Get 操作：从 remote 读，所以 remote 是 source (const)
  std::vector<uint64_t> lens(list_num);
  for (uint32_t i = 0; i < list_num; ++i) {
    remote_bufs[i] = desc_list[i].remote_buf;
    local_bufs[i] = desc_list[i].local_buf;
    lens[i] = desc_list[i].len;
  }
  hixl::CommunicateMem com_mem{};
  com_mem.list_num = list_num;
  com_mem.dst_buf_list = local_bufs.data();   // Get: 写入本地
  com_mem.src_buf_list = remote_bufs.data();  // Get: 读取远端
  com_mem.len_list = lens.data();
  void *raw_handle = nullptr;
  const auto ret = client->BatchTransfer(true, com_mem, &raw_handle);
  if (raw_handle != nullptr) {
    *complete_handle = raw_handle;
    HIXL_LOGI("HixlCSClientBatchGetAsync complete_handle create, complete_handle is %p.", complete_handle);
  }
  HIXL_CHK_STATUS_RET(ret, "HixlCSClientBatchGetAsync failed, client_handle is %p, list_num:%u", client_handle,
                      list_num);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientQueryCompleteStatus(HixlClientHandle client_handle, CompleteHandle complete_handle,
                                           HixlCompleteStatus *complete_status) {
  HIXL_CHECK_NOTNULL(client_handle);
  HIXL_CHECK_NOTNULL(complete_handle);
  HIXL_CHECK_NOTNULL(complete_status);
  auto client = static_cast<hixl::HixlCSClient *>(client_handle);
  const auto ret = client->CheckStatus(complete_handle, complete_status);
  HIXL_CHK_STATUS_RET(ret, "HixlCSClientQueryCompleteStatus failed, client_handle is %p.", client_handle);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientConnect(HixlClientHandle client_handle, uint32_t timeout_ms) {
  HIXL_CHECK_NOTNULL(client_handle);
  auto *client = static_cast<hixl::HixlCSClient *>(client_handle);
  HIXL_CHECK_NOTNULL(client);
  const auto ret = client->Connect(timeout_ms);
  HIXL_CHK_STATUS_RET(ret, "HixlCSClientConnect failed, client_handle is %p, timeout:%u", client_handle, timeout_ms);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientGetRemoteMem(HixlClientHandle client_handle, HcommMem **remote_mem_list, char ***mem_tag_list,
                                    uint32_t *list_num, uint32_t timeout_ms) {
  HIXL_CHECK_NOTNULL(client_handle);
  auto *client = static_cast<hixl::HixlCSClient *>(client_handle);
  HIXL_CHECK_NOTNULL(client);
  const auto ret = client->GetRemoteMem(remote_mem_list, mem_tag_list, list_num, timeout_ms);
  HIXL_CHK_STATUS_RET(ret, "HixlCSClientGetRemoteMem failed, client_handle is %p, timeout:%u", client_handle,
                      timeout_ms);
  return HIXL_SUCCESS;
}

HixlStatus HixlCSClientDestroy(HixlClientHandle client_handle) {
  HIXL_CHECK_NOTNULL(client_handle);
  auto *client = static_cast<hixl::HixlCSClient *>(client_handle);
  HIXL_CHECK_NOTNULL(client);
  const auto ret = client->Destroy();
  delete client;
  HIXL_CHK_STATUS_RET(ret, "HixlCSClientDestroy failed, client_handle is %p.", client_handle);
  return HIXL_SUCCESS;
}

namespace hixl {
HixlStatus HixlCSServerRegProc(HixlServerHandle server_handle, hixl::CtrlMsgType msg_type, hixl::MsgProcessor proc) {
  auto server = static_cast<hixl::HixlCSServer *>(server_handle);
  HIXL_CHECK_NOTNULL(server, ", please use handle generated by HixlCSServerCreate");
  HIXL_CHK_STATUS_RET(server->RegProc(msg_type, proc), "Failed to reg proc, msg_type:%d",
                      static_cast<int32_t>(msg_type));
  return HIXL_SUCCESS;
}
}
